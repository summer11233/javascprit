### 函数
+ 普通函数
    运行函数中的代码，为了复用
+ 构造函数（class类）
    + this实例
    + 默认返回(return)实例
    + 在类里面一般都添加属性
    + new 构造函数
### 原型和原型链
+ 函数走原型（构造函数的实例）
+ 实例走链（实例找不到某个属性或方法就走链）
+ 实例的原型链 === 构造函数的原型
### 实例
+ new Function -> function
### class
+ class 类名{
    constructor(){
        //给自身添加属性或者方法，就必须要写constructor
    }
}
+ 如果使用类，那么不能直接修改类的原型地址，修改了会出现undefined
### 所有的数据都有一个toString的方法，但是写法不一样，唯独Object的toString能够加测当前的数据类型，所以可以把this改变，达到我们的目的
### Array的toString，除了数组本身别的也都能检测数据类型
+ Array.from()   把类数组转数组
### 解构赋值
+ 数组的解构赋值：
    + 声明的时候一定要是个数组，左右两边的结构保持一致，如果两边不一致，结果会报错
```
    a = 5,b = 10
    let [x,y] = [a,b]
    console.log(x,y)  //5  10
```
+ 对象的解构赋值：
    + 在声明的时候使用块声明，块中放对象的key值，这里的key值一定要和结构对象的key值名字一致
    ```
        let {key1,key2} = {key1:val1,key2:val2}
    ```
    + 如果要取别名，使用新定义的名字接口
    + 以下代码中，key1已经访问不到了，要是访问的话就会报错，只能访问它的别名k，k就代表key1，名字跟声明变量规则一致
    ```
        let {key1:k,key2}={key1:val1,key2:val2}
    ```
    + 如果想要不报错，那么可以先解构一次，再重命名
    ```
        let {
            f, //先把f解构出来，这样就可以访问f了
            f:x
        } = {
            f:{
                name:'11',
                age:22
            }
        }
    ```
